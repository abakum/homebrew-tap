name: Update Casks, Formula and bucket via GitHub API

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-all:
    runs-on: ubuntu-latest
    
    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      # Step 2: Get latest release info via GitHub API (using Octokit)
      - name: Get latest release info via GitHub API
        id: get_release
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/abakum/crocgui/releases/latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Step 3: Extract version and SHA256 hashes from API response
      - name: Extract version and hashes
        id: extract_data
        run: |
          # Save API response to a temporary file
          echo '${{ steps.get_release.outputs.data }}' > release.json
          
          # Install jq for JSON parsing
          sudo apt-get update
          sudo apt-get install -y jq
          
          # Extract version (remove 'v' prefix)
          VERSION=$(jq -r '.tag_name | ltrimstr("v")' release.json)
          echo "Latest version: $VERSION"
          
          # Extract SHA256 hashes from the .digest field (format: 'sha256:...')
          TAR_SHA=$(jq -r '.assets[] | select(.name == "crocgui.tar.xz") | .digest // empty' release.json | cut -d: -f2)
          EXE_SHA=$(jq -r '.assets[] | select(.name == "crocgui.exe") | .digest // empty' release.json | cut -d: -f2)
          DMG_ARM_SHA=$(jq -r '.assets[] | select(.name == "crocgui-arm64.dmg") | .digest // empty' release.json | cut -d: -f2)
          DMG_INTEL_SHA=$(jq -r '.assets[] | select(.name == "crocgui-amd64.dmg") | .digest // empty' release.json | cut -d: -f2)
          
          # Verify all required hashes were found
          if [[ -z "$TAR_SHA" ]] || [[ -z "$EXE_SHA" ]] || [[ -z "$DMG_ARM_SHA" ]] || [[ -z "$DMG_INTEL_SHA" ]]; then
            echo "Error: Some SHA256 hashes not found in release assets"
            echo "Make sure all required files are present in the GitHub release"
            exit 1
          fi
          
          echo "SHA256 hashes found:"
          echo "  tar.xz (Linux): $TAR_SHA"
          echo "  exe (Windows): $EXE_SHA"
          echo "  dmg-arm64 (macOS Apple Silicon): $DMG_ARM_SHA"
          echo "  dmg-amd64 (macOS Intel): $DMG_INTEL_SHA"
          
          # Save data for subsequent steps (объединенные echo для SC2129)
          {
            echo "LATEST_VERSION=$VERSION"
            echo "TAR_SHA=$TAR_SHA"
            echo "EXE_SHA=$EXE_SHA"
            echo "DMG_ARM_SHA=$DMG_ARM_SHA"
            echo "DMG_INTEL_SHA=$DMG_INTEL_SHA"
          } >> "$GITHUB_OUTPUT"

      # Step 4: Check current versions in our package files
      - name: Check current versions in package files
        id: check_versions
        run: |
          # Read current versions from files
          CURRENT_VERSION_CASK=$(grep -oP 'version "\K[^"]+' Casks/crocgui.rb 2>/dev/null || echo "")
          CURRENT_VERSION_FORMULA=$(grep -oP 'releases/download/v\K[^/]+' Formula/crocgui.rb 2>/dev/null || echo "")
          CURRENT_VERSION_SCOOP=$(jq -r '.version // empty' bucket/crocgui.json 2>/dev/null || echo "")
          
          echo "Current versions in package files:"
          echo "  Homebrew Cask (macOS): $CURRENT_VERSION_CASK"
          echo "  Homebrew Formula (Linux): $CURRENT_VERSION_FORMULA"
          echo "  Scoop Manifest (Windows): $CURRENT_VERSION_SCOOP"
          
          LATEST_VERSION="${{ steps.extract_data.outputs.LATEST_VERSION }}"
          
          # Determine which packages need updates
          UPDATE_CASK=false
          UPDATE_FORMULA=false
          UPDATE_SCOOP=false
          
          if [[ -n "$CURRENT_VERSION_CASK" ]] && [[ "$CURRENT_VERSION_CASK" != "$LATEST_VERSION" ]]; then
            UPDATE_CASK=true
          fi
          
          if [[ -n "$CURRENT_VERSION_FORMULA" ]] && [[ "$CURRENT_VERSION_FORMULA" != "$LATEST_VERSION" ]]; then
            UPDATE_FORMULA=true
          fi
          
          if [[ -n "$CURRENT_VERSION_SCOOP" ]] && [[ "$CURRENT_VERSION_SCOOP" != "$LATEST_VERSION" ]]; then
            UPDATE_SCOOP=true
          fi
          
          echo "Updates needed:"
          echo "  Homebrew Cask: $UPDATE_CASK"
          echo "  Homebrew Formula: $UPDATE_FORMULA"
          echo "  Scoop Manifest: $UPDATE_SCOOP"
          
          # Export results for conditional steps (объединенные echo для SC2129)
          {
            echo "UPDATE_CASK=$UPDATE_CASK"
            echo "UPDATE_FORMULA=$UPDATE_FORMULA"
            echo "UPDATE_SCOOP=$UPDATE_SCOOP"
            echo "CURRENT_VERSION_CASK=$CURRENT_VERSION_CASK"
            echo "CURRENT_VERSION_FORMULA=$CURRENT_VERSION_FORMULA"
            echo "CURRENT_VERSION_SCOOP=$CURRENT_VERSION_SCOOP"
          } >> "$GITHUB_OUTPUT"

      # Step 5: Update Homebrew Cask for macOS (if needed)
      - name: Update Homebrew Cask file
        if: steps.check_versions.outputs.UPDATE_CASK == 'true'
        env:
          NEW_VERSION: "${{ steps.extract_data.outputs.LATEST_VERSION }}"
          ARM_SHA: "${{ steps.extract_data.outputs.DMG_ARM_SHA }}"
          INTEL_SHA: "${{ steps.extract_data.outputs.DMG_INTEL_SHA }}"
        run: |
          echo "Updating Homebrew Cask to version $NEW_VERSION..."
          
          ruby <<-'RUBY'
            file = "Casks/crocgui.rb"
            content = File.read(file)
            
            # Update version number
            content.gsub!(/version "[\d\.]+"/, "version \"#{ENV['NEW_VERSION']}\"")
            
            # Update SHA256 hashes for both architectures
            # Format: sha256 arm: "...", intel: "..."
            content.gsub!(/sha256\s+arm:\s*"[a-f0-9]+"/, "sha256 arm:          \"#{ENV['ARM_SHA']}\"")
            content.gsub!(/intel:\s*"[a-f0-9]+"/, "intel:        \"#{ENV['INTEL_SHA']}\"")
            
            File.write(file, content)
            puts "✅ Homebrew Cask file updated to v#{ENV['NEW_VERSION']}"
          RUBY

      # Step 6: Update Homebrew Formula for Linux (if needed)
      - name: Update Homebrew Formula file
        if: steps.check_versions.outputs.UPDATE_FORMULA == 'true'
        env:
          NEW_VERSION: "${{ steps.extract_data.outputs.LATEST_VERSION }}"
          TAR_SHA: "${{ steps.extract_data.outputs.TAR_SHA }}"
        run: |
          echo "Updating Homebrew Formula to version $NEW_VERSION..."
          
          ruby <<-'RUBY'
            file = "Formula/crocgui.rb"
            content = File.read(file)
            
            # Update download URL with new version
            old_url_pattern = %r{url "https://github\.com/abakum/crocgui/releases/download/v[\d\.]+/crocgui\.tar\.xz"}
            new_url = "url \"https://github.com/abakum/crocgui/releases/download/v#{ENV['NEW_VERSION']}/crocgui.tar.xz\""
            content.gsub!(old_url_pattern, new_url)
            
            # Update SHA256 hash
            content.gsub!(/sha256 "[a-f0-9]+"/, "sha256 \"#{ENV['TAR_SHA']}\"")
            
            File.write(file, content)
            puts "Homebrew Formula file updated to v#{ENV['NEW_VERSION']}"
          RUBY

      # Step 7: Update Scoop Manifest for Windows (if needed)
      - name: Update Scoop Manifest file
        if: steps.check_versions.outputs.UPDATE_SCOOP == 'true'
        env:
          NEW_VERSION: "${{ steps.extract_data.outputs.LATEST_VERSION }}"
          EXE_SHA: "${{ steps.extract_data.outputs.EXE_SHA }}"
        run: |
          echo "Updating Scoop Manifest to version $NEW_VERSION..."
          
          ruby <<-'RUBY'
            require 'json'
            
            file = "bucket/crocgui.json"
            
            # Read existing manifest or create template if it doesn't exist
            if File.exist?(file)
              data = JSON.parse(File.read(file))
            else
              data = {
                "version" => ENV['NEW_VERSION'],
                "description" => "GUI for croc — secure file transfer tool",
                "homepage" => "https://github.com/abakum/crocgui",
                "license" => "ISC",
                "url" => "",
                "hash" => "",
                "bin" => "crocgui.exe",
                "shortcuts" => [["crocgui.exe", "Croc GUI"]],
                "checkver" => "github",
                "autoupdate" => {
                  "url" => "https://github.com/abakum/crocgui/releases/download/v$version/crocgui.exe"
                }
              }
            end
            
            # Update manifest fields
            data["version"] = ENV['NEW_VERSION']
            data["url"] = "https://github.com/abakum/crocgui/releases/download/v#{ENV['NEW_VERSION']}/crocgui.exe"
            data["hash"] = ENV['EXE_SHA']
            
            # Write back with pretty formatting
            File.write(file, JSON.pretty_generate(data))
            puts "Scoop Manifest updated to v#{ENV['NEW_VERSION']}"
          RUBY

      # Step 8: Commit, tag and push changes DIRECTLY TO MAIN (clean tag, detailed commit)
      - name: Commit, tag and push changes to main
        if: steps.check_versions.outputs.UPDATE_CASK == 'true' || steps.check_versions.outputs.UPDATE_FORMULA == 'true' || steps.check_versions.outputs.UPDATE_SCOOP == 'true'
        env:
          TAG_NAME: "v${{ steps.extract_data.outputs.LATEST_VERSION }}"
        run: |
          # Configure git identity for the action
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add changed files to staging
          FILES_ADDED=false
          if [[ "${{ steps.check_versions.outputs.UPDATE_CASK }}" == "true" ]]; then
            git add "Casks/crocgui.rb"
            FILES_ADDED=true
          fi
          if [[ "${{ steps.check_versions.outputs.UPDATE_FORMULA }}" == "true" ]]; then
            git add "Formula/crocgui.rb"
            FILES_ADDED=true
          fi
          if [[ "${{ steps.check_versions.outputs.UPDATE_SCOOP }}" == "true" ]]; then
            git add "bucket/crocgui.json"
            FILES_ADDED=true
          fi
          
          # Exit if no files were updated
          if [[ "$FILES_ADDED" == "false" ]]; then
            echo "No files to update"
            exit 0
          fi
          
          # Check if there are actual changes to commit
          if git diff --cached --quiet; then
            echo "No changes to commit (files may already be up to date)"
            exit 0
          fi
          
          # Build descriptive commit message with version changes
          COMMIT_PARTS=()
          if [[ "${{ steps.check_versions.outputs.UPDATE_CASK }}" == "true" ]]; then
            COMMIT_PARTS+=("cask: ${{ steps.check_versions.outputs.CURRENT_VERSION_CASK }}")
          fi
          if [[ "${{ steps.check_versions.outputs.UPDATE_FORMULA }}" == "true" ]]; then
            COMMIT_PARTS+=("formula: ${{ steps.check_versions.outputs.CURRENT_VERSION_FORMULA }}")
          fi
          if [[ "${{ steps.check_versions.outputs.UPDATE_SCOOP }}" == "true" ]]; then
            COMMIT_PARTS+=("scoop: ${{ steps.check_versions.outputs.CURRENT_VERSION_SCOOP }}")
          fi
          
          # Format detailed commit message: "crocgui: Update to version 1.11.32 (cask: 1.11.31, formula: 1.11.31)"
          COMMIT_MESSAGE="crocgui: Update to version ${{ steps.extract_data.outputs.LATEST_VERSION }}"
          if [[ ${#COMMIT_PARTS[@]} -gt 0 ]]; then
            COMMIT_MESSAGE="$COMMIT_MESSAGE (${COMMIT_PARTS[0]}"
            for i in "${!COMMIT_PARTS[@]}"; do
              if [[ $i -gt 0 ]]; then
                COMMIT_MESSAGE="$COMMIT_MESSAGE, ${COMMIT_PARTS[$i]}"
              fi
            done
            COMMIT_MESSAGE="$COMMIT_MESSAGE)"
          fi
          
          # Clean tag message without package details: "crocgui: Update to version 1.11.32"
          TAG_MESSAGE="crocgui: Update to version ${{ steps.extract_data.outputs.LATEST_VERSION }}"
          
          echo "Commit message: $COMMIT_MESSAGE"
          echo "Tag message: $TAG_MESSAGE"
          echo "Tag name: $TAG_NAME"
          
          # Create the commit with detailed message
          git commit -m "$COMMIT_MESSAGE"
          COMMIT_HASH=$(git rev-parse HEAD)
          
          # Create annotated tag with clean message
          git tag -a "$TAG_NAME" -m "$TAG_MESSAGE" "$COMMIT_HASH"
          
          # Single push for both commit and tag (atomic ensures both succeed or neither)
          echo "Pushing commit and tag to main branch..."
          git push origin main --atomic
          git push origin "$TAG_NAME"    # Additional push for redundancy
          
          echo "Changes successfully pushed to main branch with tag $TAG_NAME"
          echo "Package files updated for:"
          if [[ "${{ steps.check_versions.outputs.UPDATE_CASK }}" == "true" ]]; then
            echo "   - macOS (Homebrew Cask)"
          fi
          if [[ "${{ steps.check_versions.outputs.UPDATE_FORMULA }}" == "true" ]]; then
            echo "   - Linux (Homebrew Formula)" 
          fi
          if [[ "${{ steps.check_versions.outputs.UPDATE_SCOOP }}" == "true" ]]; then
            echo "   - Windows (Scoop Manifest)"
          fi
